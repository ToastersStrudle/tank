const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const keys = {};
DK6q4Jgad9g8NTMKuWJaovRBCxvKXMYzta', e => keys[e.key] = true);
document.addEventListener('keyup', e => keys[e.key] = false);

let level = 1;
let enemies = [];
let nextLevelDelay = 0;
let isGameOver = false;

class Tank {
  constructor(x, y, color = 'green') {
    this.x = x;
    this.y = y;
    this.width = 40;
    this.height = 40;
    this.speed = 2;
    this.color = color;
    this.direction = 'up';
    this.health = 100;
  }

  draw() {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
    ctx.fillStyle = 'black';
    if (this.direction === 'up') ctx.fillRect(this.x + 15, this.y - 10, 10, 10);
    if (this.direction === 'down') ctx.fillRect(this.x + 15, this.y + 40, 10, 10);
    if (this.direction === 'left') ctx.fillRect(this.x - 10, this.y + 15, 10, 10);
    if (this.direction === 'right') ctx.fillRect(this.x + 40, this.y + 15, 10, 10);
  }

  move() {
    if (keys['ArrowUp']) this.y -= this.speed, this.direction = 'up';
    if (keys['ArrowDown']) this.y += this.speed, this.direction = 'down';
    if (keys['ArrowLeft']) this.x -= this.speed, this.direction = 'left';
    if (keys['ArrowRight']) this.x += this.speed, this.direction = 'right';

    this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
    this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));
  }
}

class Bullet {
  constructor(x, y, direction) {
    this.x = x;
    this.y = y;
    this.direction = direction;
    this.speed = 5;
    this.size = 5;
  }

  move() {
    if (this.direction === 'up') this.y -= this.speed;
    if (this.direction === 'down') this.y += this.speed;
    if (this.direction === 'left') this.x -= this.speed;
    if (this.direction === 'right') this.x += this.speed;
  }

  draw() {
    ctx.fillStyle = 'yellow';
    ctx.fillRect(this.x, this.y, this.size, this.size);
  }

  isOffScreen() {
    return (
      this.x < 0 || this.x > canvas.width ||
      this.y < 0 || this.y > canvas.height
    );
  }
}

class EnemyBullet {
  constructor(x, y, vx, vy) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.size = 5;
    this.speed = 3;
  }

  move() {
    this.x += this.vx * this.speed;
    this.y += this.vy * this.speed;
  }

  draw() {
    ctx.fillStyle = 'red';
    ctx.fillRect(this.x, this.y, this.size, this.size);
  }

  isOffScreen() {
    return (
      this.x < 0 || this.x > canvas.width ||
      this.y < 0 || this.y > canvas.height
    );
  }
}

class Enemy extends Tank {
  constructor(x, y) {
    super(x, y, 'red');
    this.moveCooldown = 0;
    this.shootCooldown = 60 + Math.random() * 60;
  }

  update() {
    if (this.moveCooldown <= 0) {
      const dirs = ['up', 'down', 'left', 'right'];
      this.direction = dirs[Math.floor(Math.random() * dirs.length)];
      this.moveCooldown = 50;
    } else {
      this.moveCooldown--;
    }

    if (this.direction === 'up') this.y -= this.speed;
    if (this.direction === 'down') this.y += this.speed;
    if (this.direction === 'left') this.x -= this.speed;
    if (this.direction === 'right') this.x += this.speed;

    this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
    this.y = Math.max(0, Math.min(canvas.height - this.height, this.y));

    this.shootCooldown--;
    if (this.shootCooldown <= 0) {
      this.shootAtPlayer();
      this.shootCooldown = 90 + Math.random() * 60;
    }
  }

  shootAtPlayer() {
    const dx = player.x + player.width / 2 - (this.x + this.width / 2);
    const dy = player.y + player.height / 2 - (this.y + this.height / 2);
    const len = Math.sqrt(dx * dx + dy * dy);
    const vx = dx / len;
    const vy = dy / len;
    enemyBullets.push(new EnemyBullet(this.x + 20, this.y + 20, vx, vy));
  }
}

const player = new Tank(100, 100);
const bullets = [];
const enemyBullets = [];

function spawnEnemies(level) {
  const newEnemies = [];
  for (let i = 0; i < level + 1; i++) {
    const x = Math.random() * (canvas.width - 40);
    const y = Math.random() * (canvas.height - 40);
    newEnemies.push(new Enemy(x, y));
  }
  return newEnemies;
}

function showLevelText() {
  ctx.fillStyle = 'red';
  ctx.font = '30px Arial';
  ctx.fillText(`Level ${level}`, canvas.width / 2 - 60, canvas.height / 2);
}

function drawHealthBar() {
  ctx.fillStyle = 'gray';
  ctx.fillRect(20, 20, 100, 10);
  ctx.fillStyle = 'lime';
  ctx.fillRect(20, 20, player.health, 10);
  ctx.strokeStyle = 'white';
  ctx.strokeRect(20, 20, 100, 10);
}

function showGameOver() {
  ctx.fillStyle = 'red';
  ctx.font = '40px Arial';
  ctx.fillText('GAME OVER YOU DIED', canvas.width / 2 - 110, canvas.height / 2);
}

let shootCooldown = 0;

function gameLoop() {
  // Set the background color based on the level or any condition
  ctx.fillStyle = '#FF69B4'; // Set background to pink
  ctx.fillRect(0, 0, canvas.width, canvas.height); // Fill the whole canvas with the color

  if (isGameOver) {
    showGameOver();
    return;
  }

  if (nextLevelDelay > 0) {
    showLevelText();
    nextLevelDelay--;
    if (nextLevelDelay === 0) {
      enemies = spawnEnemies(level);
    }
    requestAnimationFrame(gameLoop);
    return;
  }

  player.move();
  player.draw();
  drawHealthBar();

  if (keys[' '] && shootCooldown <= 0) {
    let bx = player.x + 17;
    let by = player.y + 17;
    bullets.push(new Bullet(bx, by, player.direction));
    shootCooldown = 15;
  }
  if (shootCooldown > 0) shootCooldown--;

  bullets.forEach((b, i) => {
    b.move();
    b.draw();
    if (b.isOffScreen()) bullets.splice(i, 1);
  });

  enemyBullets.forEach((b, i) => {
    b.move();
    b.draw();
    if (b.isOffScreen()) enemyBullets.splice(i, 1);

    // Collision with player
    if (
      b.x < player.x + player.width &&
      b.x + b.size > player.x &&
      b.y < player.y + player.height &&
      b.y + b.size > player.y
    ) {
      player.health -= 10;
      enemyBullets.splice(i, 1);

      if (player.health <= 0) {
        isGameOver = true;
        document.getElementById("restart-btn").style.display = "block";
      }
    }
  });

  enemies.forEach(enemy => {
    enemy.update();
    enemy.draw();
  });

  bullets.forEach((bullet, bIndex) => {
    enemies.forEach((enemy, eIndex) => {
      if (
        bullet.x < enemy.x + enemy.width &&
        bullet.x + bullet.size > enemy.x &&
        bullet.y < enemy.y + enemy.height &&
        bullet.y + bullet.size > enemy.y
      ) {
        enemies.splice(eIndex, 1);
        bullets.splice(bIndex, 1);
      }
    });
  });

  if (enemies.length === 0 && nextLevelDelay === 0) {
    level++;
    nextLevelDelay = 90;
  }

  requestAnimationFrame(gameLoop);
}

document.getElementById("restart-btn").addEventListener("click", () => {
  player.health = 100;
  player.lives = 1;
  document.getElementById("lives-count").textContent = player.lives;
  enemies = spawnEnemies(level);
  document.getElementById("restart-btn").style.display = "none";
  isGameOver = false;
  gameLoop();
});

enemies = spawnEnemies(level);
gameLoop();
// Full-screen toggle function
function toggleFullscreen() {
  if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.mozFullScreenElement && !document.msFullscreenElement) {
    if (canvas.requestFullscreen) {
      canvas.requestFullscreen();
    } else if (canvas.msRequestFullscreen) {
      canvas.msRequestFullscreen();
    } else if (canvas.mozRequestFullScreen) {
      canvas.mozRequestFullScreen();
    } else if (canvas.webkitRequestFullscreen) {
      canvas.webkitRequestFullscreen();
    }
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    }
  }
}

// Add event listener for full-screen button
document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);

// Fullscreen change event listeners (optional, for adjusting the game canvas when entering/exiting fullscreen)
document.addEventListener('fullscreenchange', resizeCanvas);
document.addEventListener('webkitfullscreenchange', resizeCanvas);
document.addEventListener('mozfullscreenchange', resizeCanvas);
document.addEventListener('MSFullscreenChange', resizeCanvas);

// Function to resize canvas when switching to full-screen
function resizeCanvas() {
  if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement) {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  } else {
    canvas.width = 800; // Default width
    canvas.height = 600; // Default height
  }
}
