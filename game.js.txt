const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let tank = {
    x: canvas.width / 2,
    y: canvas.height / 2,
    width: 50,
    height: 50,
    speed: 5,
    color: 'green',
    health: 100,
    direction: 0, // 0 = up, 1 = right, 2 = down, 3 = left
    turretAngle: 0, // Angle of turret
    shootCooldown: 0,
    turretLength: 20,
    rotationSpeed: 0.05,
    armor: 0,
};

let bullets = [];
let enemies = [];
let explosions = [];

let lastUpdateTime = Date.now();

let currentLevel = 1;
let levelEnemyCount = 2;
let bossLevelInterval = 10; // Every 10 levels, a boss will appear

let levelComplete = false; // Flag to indicate when the level is complete

let coins = 0; // Player's coins

let gameState = "menu"; // Current state: "menu" or "game"
let upgradeState = "none"; // Track upgrade menu state (none, color, speed, health)

let tankUpgrades = {
    speed: 5,
    health: 100,
    damage: 100,
};

// Controls
let keys = { left: false, up: false, right: false, down: false, shoot: false };

DK6q4Jgad9g8NTMKuWJaovRBCxvKXMYzta", (e) => {
    if (e.key === "ArrowLeft") keys.left = true;
    if (e.key === "ArrowUp") keys.up = true;
    if (e.key === "ArrowRight") keys.right = true;
    if (e.key === "ArrowDown") keys.down = true;
    if (e.key === " ") keys.shoot = true;
});

document.addEventListener("keyup", (e) => {
    if (e.key === "ArrowLeft") keys.left = false;
    if (e.key === "ArrowUp") keys.up = false;
    if (e.key === "ArrowRight") keys.right = false;
    if (e.key === "ArrowDown") keys.down = false;
    if (e.key === " ") keys.shoot = false;
});

// Tank movement and turret control
function updateTank() {
    if (keys.left) tank.x -= tank.speed;
    if (keys.up) tank.y -= tank.speed;
    if (keys.right) tank.x += tank.speed;
    if (keys.down) tank.y += tank.speed;

    // Turret rotation
    if (keys.right) tank.turretAngle += tank.rotationSpeed;
    if (keys.left) tank.turretAngle -= tank.rotationSpeed;

    // Keep the tank within bounds
    tank.x = Math.max(0, Math.min(tank.x, canvas.width - tank.width));
    tank.y = Math.max(0, Math.min(tank.y, canvas.height - tank.height));
}

// Shooting bullets
function shootBullet() {
    if (keys.shoot && tank.shootCooldown <= 0) {
        let bullet = {
            x: tank.x + tank.width / 2,
            y: tank.y + tank.height / 2,
            radius: 5,
            speed: 7,
            angle: tank.turretAngle,
            damage: tankUpgrades.damage, // Bullet damage is based on upgrade
        };
        bullets.push(bullet);
        tank.shootCooldown = 20;  // Cooldown for shooting
    }
}

// Draw the tank and turret
function drawTank() {
    ctx.save();
    ctx.translate(tank.x + tank.width / 2, tank.y + tank.height / 2);
    ctx.rotate(tank.turretAngle);

    // Tank body
    ctx.fillStyle = tank.color;
    ctx.fillRect(-tank.width / 2, -tank.height / 2, tank.width, tank.height);

    // Turret
    ctx.fillStyle = 'black';
    ctx.fillRect(0, -5, tank.turretLength, 10);

    ctx.restore();
}

// Bullet movement and collisions
function updateBullets() {
    for (let i = 0; i < bullets.length; i++) {
        let bullet = bullets[i];
        bullet.x += Math.cos(bullet.angle) * bullet.speed;
        bullet.y += Math.sin(bullet.angle) * bullet.speed;

        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
        ctx.fillStyle = 'black';
        ctx.fill();
        ctx.closePath();

        if (bullet.x < 0 || bullet.x > canvas.width || bullet.y < 0 || bullet.y > canvas.height) {
            bullets.splice(i, 1);
            i--;
        }
    }
}

// Create enemies (with random movement and shooting at player)
function createEnemies() {
    if (enemies.length === 0 && !levelComplete) {
        for (let i = 0; i < levelEnemyCount; i++) {
            let enemy = {
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                width: 50,
                height: 50,
                speed: 2 + Math.random() * 2,
                health: 100, // Set health to 100
                color: 'red',
                direction: Math.random() * Math.PI * 2, // Random direction
                shootCooldown: Math.random() * 60 + 30, // Random cooldown between 30 and 90 frames
                damage: 10, // Enemy damage when colliding
            };
            enemies.push(enemy);
        }
    }
}

// Update enemy movement and shooting
function updateEnemies() {
    for (let i = 0; i < enemies.length; i++) {
        let enemy = enemies[i];

        // Random movement
        enemy.x += Math.cos(enemy.direction) * enemy.speed;
        enemy.y += Math.sin(enemy.direction) * enemy.speed;

        // Keep enemies inside bounds
        if (enemy.x < 0 || enemy.x > canvas.width) enemy.direction = Math.PI - enemy.direction;
        if (enemy.y < 0 || enemy.y > canvas.height) enemy.direction = -enemy.direction;

        // Enemy shooting at player
        if (enemy.shootCooldown <= 0) {
            let bullet = {
                x: enemy.x + enemy.width / 2,
                y: enemy.y + enemy.height / 2,
                radius: 8,
                speed: 6,
                angle: Math.atan2(tank.y - enemy.y, tank.x - enemy.x),
                damage: enemy.damage, // Enemy bullets will also cause damage
            };
            bullets.push(bullet);
            enemy.shootCooldown = Math.random() * 60 + 30; // Reset cooldown
        }

        // Decrease cooldown
        enemy.shootCooldown--;

        ctx.fillStyle = enemy.color;
        ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
    }
}

// Check for collisions with bullets and enemies
function detectCollisions() {
    // Check for player collisions with enemies (tank gets damaged if close to an enemy)
    for (let i = 0; i < enemies.length; i++) {
        let enemy = enemies[i];
        let distance = Math.hypot(tank.x - enemy.x, tank.y - enemy.y);

        // If the distance between the tank and an enemy is less than a certain threshold, damage the player
        if (distance < (tank.width / 2 + enemy.width / 2)) {
            tank.health -= enemy.damage;
        }
    }

    // Check for collisions with bullets and enemies
    for (let i = 0; i < bullets.length; i++) {
        for (let j = 0; j < enemies.length; j++) {
            let bullet = bullets[i];
            let enemy = enemies[j];
            if (bullet.x > enemy.x && bullet.x < enemy.x + enemy.width &&
                bullet.y > enemy.y && bullet.y < enemy.y + enemy.height) {

                // Only reduce health if bullet's damage is 100 (player's bullet)
                if (bullet.damage === 100) {
                    enemy.health -= bullet.damage;
                }

                if (enemy.health <= 0) {
                    explosions.push({ x: enemy.x, y: enemy.y, size: 20 });
                    enemies.splice(j, 1);
                    coins += 5; // Add 5 coins for killing an enemy
                    i--;
                }
                bullets.splice(i, 1);
                break;
            }
        }
    }
}

// Create explosion effects
function drawExplosions() {
    for (let i = 0; i < explosions.length; i++) {
        let explosion = explosions[i];
        ctx.beginPath();
        ctx.arc(explosion.x, explosion.y, explosion.size, 0, Math.PI * 2);
        ctx.fillStyle = 'yellow';
        ctx.fill();
        explosion.size += 2;
        if (explosion.size > 40) {
            explosions.splice(i, 1);
            i--;
        }
    }
}

// Draw level information and coins
function drawLevelInfo() {
    ctx.font = "20px Arial";
    ctx.fillStyle = 'black';
    ctx.fillText(`Level: ${currentLevel}`, 10, 30);
    ctx.fillText(`Enemies Left: ${enemies.length}`, canvas.width - 150, 30);
    ctx.fillText(`Player Health: ${tank.health}`, 10, 60);
    ctx.fillText(`Coins: ${coins}`, canvas.width - 150, 60); // Display coins
}

// Update the level and difficulty
function checkLevelCompletion() {
    if (enemies.length === 0 && !levelComplete) {
        levelComplete = true;
        setTimeout(() => {
            currentLevel++; 
            levelEnemyCount += 2; // Increase enemies per level
            enemies = []; // Clear enemies for the new level
            coins += 10; // Add 10 coins for completing the level
            levelComplete = false; // Reset level completion status
        }, 1000); // Brief pause before next level
    }
}

// Main menu function
function drawMainMenu() {
    ctx.fillStyle = 'lightgray';
    ctx.fillRect(0, 0, canvas.width, canvas.height); // Background for the menu

    ctx.fillStyle = 'black';
    ctx.font = '30px Arial';
    ctx.fillText('Main Menu', canvas.width / 2 - 75, canvas.height / 4);

    // Draw buttons (start game, upgrades, quit)
    ctx.font = '20px Arial';
    ctx.fillText('Start Game', canvas.width / 2 - 60, canvas.height / 2 - 40);
    ctx.fillText('Upgrades', canvas.width / 2 - 60, canvas.height / 2);
    ctx.fillText('Quit', canvas.width / 2 - 60, canvas.height / 2 + 40);
}

// Game over screen
function drawGameOverScreen() {
    ctx.fillStyle = 'black';
    ctx.font = '30px Arial';
    ctx.fillText('Game Over!', canvas.width / 2 - 75, canvas.height / 4);
    ctx.fillText(`Coins: ${coins}`, canvas.width / 2 - 60, canvas.height / 2);
    ctx.fillText('Click to Restart', canvas.width / 2 - 90, canvas.height / 2 + 40);
}

// Restart game
function restartGame() {
    // Reset all game parameters
    tank = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        width: 50,
        height: 50,
        speed: 5,
        color: 'green',
        health: 100,
        direction: 0,
        turretAngle: 0,
        shootCooldown: 0,
        turretLength: 20,
        rotationSpeed: 0.05,
        armor: 0,
    };

    enemies = [];
    bullets = [];
    explosions = [];
    coins = 0;
    currentLevel = 1;
    levelEnemyCount = 2;
    levelComplete = false;
    gameState = "game"; // Set the game state to "game" after restarting
}

// Mouse event listener for menu and restart
canvas.addEventListener('click', (e) => {
    if (gameState === 'menu') {
        // Check if the "Start Game" button was clicked
        if (e.offsetY >= canvas.height / 2 - 40 && e.offsetY <= canvas.height / 2 - 10) {
            gameState = 'game';
        }
        // Check if the "Upgrades" button was clicked
        if (e.offsetY >= canvas.height / 2 && e.offsetY <= canvas.height / 2 + 30) {
            gameState = 'upgrades'; // Show upgrades screen
        }
        // Check if the "Quit" button was clicked
        if (e.offsetY >= canvas.height / 2 + 40 && e.offsetY <= canvas.height / 2 + 70) {
            window.close();
        }
    } else if (gameState === 'gameover') {
        // Restart the game
        restartGame();
    }
});

// Game loop
function update() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (gameState === 'menu') {
        drawMainMenu();
    } else if (gameState === 'game') {
        // Gameplay logic here
        createEnemies();
        updateTank();
        shootBullet();
        updateBullets();
        updateEnemies();
        detectCollisions();
        drawExplosions();
        drawTank();
        drawLevelInfo();

        checkLevelCompletion();

        // Check if player health is 0, then go to gameover state
        if (tank.health <= 0) {
            gameState = 'gameover';
        }

        // Decrease cooldown after each frame
        if (tank.shootCooldown > 0) tank.shootCooldown--;
    } else if (gameState === 'gameover') {
        drawGameOverScreen();
    }

    requestAnimationFrame(update);
}

update();

